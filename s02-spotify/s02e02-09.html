<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Playlist Cloud – Genres, Danceability & Tempo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, sans-serif;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script>
  let canvas;
  let rowsData = [];
  let circles = [];

  const MIN_DIAMETER = 4;
  const MAX_DIAMETER = 20;

  let tempoMin = Infinity;
  let tempoMax = -Infinity;
  let layoutBaseSize = 1000; // used for normalized collision distances

  let hoveredIndex = -1;

  // Fixed styles for the 6 genres
  // HSB (hue 0–360, sat 0–100, bright 0–100)
  const GENRE_STYLES = {
    "Pop":  { h: 330, s: 80, b: 100 }, // pink
    "Rap":  { h: 30,  s: 80, b: 65 },  // brownish
    "Latin":{ h: 50,  s: 90, b: 100 }, // yellow
    "R&b":  { h: 210, s: 80, b: 100 }, // blue
    "Rock": { h: 0,   s: 90, b: 100 }, // red
    "Edm":  { h: 0,   s: 0,  b: 70 }   // gray
  };
  const LEGEND_ORDER = ["Pop", "Rap", "Latin", "R&b", "Rock", "Edm"];

  // genre -> {h,s,b} actually used (only those present in this CSV)
  let genreColors = {};
  // genre -> center in normalized coordinates [0,1]
  let genreCenters = {};
  let nextHue = 0; // fallback hue for unexpected genres

  function setup() {
    canvas = createCanvas(windowWidth, windowHeight);
    canvas.drop(handleFile);
    colorMode(HSB, 360, 100, 100, 100);
  }

  function draw() {
    background(0);

    if (circles.length === 0) {
      drawInstructions();
      return;
    }

    const t = millis() / 1000.0;
    const margin = MAX_DIAMETER * 2;
    const usableW = max(width - margin * 2, 10);
    const usableH = max(height - margin * 2, 10);

    hoveredIndex = -1;
    let closestDistSq = Infinity;

    // 1) Compute screen positions, animated diameter, and hover
    for (let i = 0; i < circles.length; i++) {
      const c = circles[i];

      // map normalized (0–1) to screen coords with margin
      const x = margin + c.nx * usableW;
      const y = margin + c.ny * usableH;
      c.x = x;
      c.y = y;

      // pulse animation based on tempo
      const speed = 0.5 + c.tempoNorm * 2.0; // 0.5–2.5 "pulses" per second
      const pulse = sin(TWO_PI * speed * t + c.phase);
      const amp = 0.18; // 18% size variation
      const d = c.baseD * (1 + amp * pulse);
      c.currentD = d;

      // hover detection
      const dx = mouseX - x;
      const dy = mouseY - y;
      const distSq = dx * dx + dy * dy;
      const radius = d / 2;
      if (distSq < radius * radius) {
        if (distSq < closestDistSq) {
          closestDistSq = distSq;
          hoveredIndex = i;
        }
      }
    }

    // cursor feedback
    if (hoveredIndex >= 0) {
      cursor('pointer');
    } else {
      cursor('default');
    }

    // 2) Draw circles (hovered on top with outline)
    noStroke();
    for (let i = 0; i < circles.length; i++) {
      const c = circles[i];
      const d = c.currentD || c.baseD;

      if (i === hoveredIndex) {
        stroke(0, 0, 100, 90); // white outline
        strokeWeight(1);
        fill(c.h, c.s, c.b, 85);
        circle(c.x, c.y, d * 1.1);
        noStroke();
      } else {
        fill(c.h, c.s, c.b, 70);
        circle(c.x, c.y, d);
      }
    }

    drawOverlay();
    drawLegend();
    drawTooltip();
  }

  function drawInstructions() {
    fill(0, 0, 90);
    textAlign(CENTER, CENTER);
    textSize(24);
    text("Drop a CSV file onto the screen", width / 2, height / 2 - 20);
    textSize(14);
    text("Color = playlist_genre · Size = danceability · Pulse = tempo", width / 2, height / 2 + 10);
  }

  function drawOverlay() {
    fill(0, 0, 100, 80);
    textAlign(LEFT, TOP);
    textSize(12);
    const genreCount = Object.keys(genreColors).length;
    text(
      `Rows: ${rowsData.length}  |  Circles: ${circles.length}  |  Genres: ${genreCount}`,
      10,
      10
    );
  }

  function drawLegend() {
    const present = Object.keys(genreColors);
    if (!present.length) return;

    // Show in requested fixed order first, then any extra unexpected genres
    const ordered = [];
    for (let g of LEGEND_ORDER) {
      if (genreColors[g]) ordered.push(g);
    }
    for (let g of present) {
      if (!LEGEND_ORDER.includes(g)) ordered.push(g);
    }

    const x = width - 190;
    let y = 20;
    const swatchSize = 10;
    const lineHeight = 16;
    const panelHeight = lineHeight * ordered.length + 18;

    push();
    noStroke();
    fill(0, 0, 0, 160);
    rect(x - 12, y - 12, 180, panelHeight, 6);
    pop();

    textAlign(LEFT, CENTER);
    textSize(11);

    for (let i = 0; i < ordered.length; i++) {
      const g = ordered[i];
      const style = genreColors[g];
      const yy = y + i * lineHeight;

      fill(style.h, style.s, style.b, 90);
      rect(x, yy - swatchSize / 2, swatchSize, swatchSize, 2);

      fill(0, 0, 95, 100);
      text(g, x + swatchSize + 6, yy);
    }
  }

  function drawTooltip() {
    if (hoveredIndex < 0) return;
    const c = circles[hoveredIndex];
    const row = rowsData[c.rowIndex];
    if (!row) return;

    const lines = [];
    if (row.track) lines.push(row.track);
    if (row.artist) lines.push("by " + row.artist);
    lines.push(row.genre || "Unknown genre");
    if (row.tempo != null) lines.push(`Tempo: ${Math.round(row.tempo)} BPM`);
    if (typeof row.dance === "number") {
      lines.push(`Danceability: ${row.dance.toFixed(2)}`);
    }

    textSize(12);
    textAlign(LEFT, TOP);

    const padding = 8;
    const lineHeight = 14;
    let w = 0;
    for (let l of lines) {
      w = max(w, textWidth(l));
    }

    let x = mouseX + 16;
    let y = mouseY + 16;
    const h = lineHeight * lines.length + padding * 2;

    // keep tooltip on-screen
    if (x + w + padding * 2 > width) {
      x = width - w - padding * 2 - 10;
    }
    if (y + h > height) {
      y = height - h - 10;
    }

    push();
    noStroke();
    fill(0, 0, 0, 210);
    rect(x, y, w + padding * 2, h, 6);

    fill(0, 0, 100, 100);
    let ty = y + padding;
    for (let l of lines) {
      text(l, x + padding, ty);
      ty += lineHeight;
    }
    pop();
  }

  function windowResized() {
    // We only scale positions; we DO NOT recompute the layout,
    // so the cloud keeps its shape and resize feels smooth.
    resizeCanvas(windowWidth, windowHeight);
  }

  function handleFile(file) {
    if (file.type === "text") {
      parseCSV(file.data);
    } else {
      console.log("Not a text file");
    }
  }

  function parseCSV(csvText) {
    const lines = csvText
      .trim()
      .split(/\r?\n/)
      .filter((l) => l.trim().length > 0);

    if (lines.length < 2) {
      console.warn("CSV seems to have no data.");
      return;
    }

    const firstLine = lines[0];
    const delimiter =
      firstLine.split(";").length > firstLine.split(",").length ? ";" : ",";

    const headers = firstLine.split(delimiter).map((h) => h.trim());

    const genreIndex  = headers.indexOf("playlist_genre");
    const danceIndex  = headers.indexOf("danceability");
    const artistIndex = headers.indexOf("artist_name");
    const trackIndex  = headers.indexOf("track_name");
    const urlIndex    = headers.indexOf("spotify_url");
    const tempoIndex  = headers.indexOf("tempo");

    if (genreIndex === -1 || danceIndex === -1) {
      console.warn("CSV must contain playlist_genre and danceability columns.");
      return;
    }

    rowsData = [];
    genreColors = {};
    genreCenters = {};
    nextHue = 0;
    tempoMin = Infinity;
    tempoMax = -Infinity;
    layoutBaseSize = min(width, height);

    for (let i = 1; i < lines.length; i++) {
      const parts = lines[i].split(delimiter);
      if (parts.length < headers.length) continue;

      const rawGenre = (parts[genreIndex] || "").trim();
      const genre = canonicalGenre(rawGenre) || "Unknown";

      let dance = parseFloat((parts[danceIndex] || "").trim());
      if (isNaN(dance)) dance = 0.5;
      dance = constrain(dance, 0, 1);

      const artist =
        artistIndex !== -1 && parts[artistIndex]
          ? parts[artistIndex].trim()
          : "";
      const track =
        trackIndex !== -1 && parts[trackIndex]
          ? parts[trackIndex].trim()
          : "";
      const url =
        urlIndex !== -1 && parts[urlIndex] ? parts[urlIndex].trim() : "";

      let tempo = null;
      if (tempoIndex !== -1 && parts[tempoIndex]) {
        const tVal = parseFloat(parts[tempoIndex].trim());
        if (!isNaN(tVal)) tempo = tVal;
      }

      if (tempo != null) {
        tempoMin = min(tempoMin, tempo);
        tempoMax = max(tempoMax, tempo);
      }

      rowsData.push({ genre, dance, artist, track, url, tempo });
    }

    if (!isFinite(tempoMin) || !isFinite(tempoMax) || tempoMin === tempoMax) {
      tempoMin = 0;
      tempoMax = 1;
    }

    computeGenreCenters();
    generateCirclesFromData();
  }

  // Map raw CSV genre string to canonical form
  function canonicalGenre(raw) {
    if (!raw) return null;
    const g = raw.trim().toLowerCase();

    if (g === "pop") return "Pop";
    if (g === "rap" || g === "hip-hop" || g === "hip hop") return "Rap";
    if (g === "latin") return "Latin";
    if (g === "r&b" || g === "rnb" || g === "r&b;") return "R&b";
    if (g === "rock") return "Rock";
    if (g === "edm" || g === "dance" || g === "dance/electronic") return "Edm";

    // fallback: keep original casing (first char upper)
    return raw.charAt(0).toUpperCase() + raw.slice(1);
  }

  function ensureGenreStyle(genre) {
    if (!genre) genre = "Unknown";

    if (GENRE_STYLES[genre]) {
      genreColors[genre] = GENRE_STYLES[genre];
      return genreColors[genre];
    }

    if (!genreColors[genre]) {
      genreColors[genre] = { h: nextHue, s: 80, b: 90 };
      nextHue = (nextHue + 40) % 360;
    }
    return genreColors[genre];
  }

  // Compute genre cluster centers in normalized [0,1] coords
  function computeGenreCenters() {
    const genres = [...new Set(rowsData.map((r) => r.genre))];
    if (!genres.length) {
      genreCenters = {};
      return;
    }

    const cx = 0.5;
    const cy = 0.5;
    const radius = 0.22; // distance from center for each cluster
    const step = TWO_PI / genres.length;

    genreCenters = {};
    for (let i = 0; i < genres.length; i++) {
      const g = genres[i];
      const angle = i * step;
      const r = genres.length === 1 ? 0 : radius;
      const nx = cx + r * cos(angle);
      const ny = cy + r * sin(angle);

      genreCenters[g] = {
        nx: constrain(nx, 0.1, 0.9),
        ny: constrain(ny, 0.1, 0.9)
      };
    }
  }

  // Pack circles in one cloud, clustered by genre, in normalized space
  function generateCirclesFromData() {
    circles = [];
    const baseSize = layoutBaseSize || min(width, height) || 1;

    const spreadNorm = 0.18; // how far points wander from genre center
    const marginNorm = (MAX_DIAMETER * 2) / baseSize;
    const cushionNorm = 1 / baseSize;
    const maxAttempts = 25;

    for (let i = 0; i < rowsData.length; i++) {
      const row = rowsData[i];
      const genre = row.genre;
      const center = genreCenters[genre] || { nx: 0.5, ny: 0.5 };
      const style = ensureGenreStyle(genre);

      const baseD = map(row.dance, 0, 1, MIN_DIAMETER, MAX_DIAMETER);
      const baseDNorm = baseD / baseSize;

      let tempoNorm = 0.5;
      if (row.tempo != null && tempoMax > tempoMin) {
        tempoNorm = (row.tempo - tempoMin) / (tempoMax - tempoMin);
        tempoNorm = constrain(tempoNorm, 0, 1);
      }

      let chosenNX = center.nx;
      let chosenNY = center.ny;
      let found = false;

      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const angle = random(TWO_PI);
        const rNorm = random(spreadNorm);
        const nx = center.nx + rNorm * cos(angle);
        const ny = center.ny + rNorm * sin(angle);

        if (
          nx < marginNorm ||
          nx > 1 - marginNorm ||
          ny < marginNorm ||
          ny > 1 - marginNorm
        ) {
          continue;
        }

        let ok = true;
        for (let c of circles) {
          const minSepNorm = (baseDNorm + c.baseDNorm) * 0.52 + cushionNorm;
          const dx = nx - c.nx;
          const dy = ny - c.ny;
          if (dx * dx + dy * dy < minSepNorm * minSepNorm) {
            ok = false;
            break;
          }
        }

        if (ok) {
          chosenNX = nx;
          chosenNY = ny;
          found = true;
          break;
        }
      }

      if (!found) {
        // fallback: place near center, gently clamped
        const angle = random(TWO_PI);
        const rNorm = random(spreadNorm);
        chosenNX = center.nx + rNorm * cos(angle);
        chosenNY = center.ny + rNorm * sin(angle);
        chosenNX = constrain(chosenNX, marginNorm, 1 - marginNorm);
        chosenNY = constrain(chosenNY, marginNorm, 1 - marginNorm);
      }

      circles.push({
        nx: chosenNX,
        ny: chosenNY,
        baseD,
        baseDNorm,
        h: style.h,
        s: style.s,
        b: style.b,
        tempoNorm,
        phase: random(TWO_PI),
        rowIndex: i,
        currentD: baseD
      });
    }
  }

  // Click → open spotify_url
  function mousePressed() {
    if (hoveredIndex < 0) return;
    const c = circles[hoveredIndex];
    const row = rowsData[c.rowIndex];
    if (row && row.url) {
      window.open(row.url, "_blank");
    }
  }
</script>
</body>
</html>
