<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Playlist Cloud – Genres, Danceability & Tempo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
                   "Segoe UI", Roboto, sans-serif;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script>
  let canvas;
  let rowsData = [];    // raw row info: cluster, genre, dance, artist, track, url, tempo
  let circles = [];     // layout info per point

  let tempoMin = Infinity;
  let tempoMax = -Infinity;
  let hoveredIndex = -1;

  // Circle size as a fraction of min(windowWidth, windowHeight)
  const MIN_SIZE_FRAC = 0.006; // 0.6% of min dimension
  const MAX_SIZE_FRAC = 0.02;  // 2% of min dimension

  // Normalized layout (0–1 space)
  const SPREAD_NORM_BASE = 0.18;               // base cluster spread radius
  const MAX_ATTEMPTS = 40;                     // placement attempts per node
  const CUSHION_NORM = MAX_SIZE_FRAC * 0.4;    // extra spacing between circles
  const MARGIN_NORM = MAX_SIZE_FRAC * 3.0;     // margin padding from edges

  // Only these 6 genres are used for legend + fixed colors
  const CANONICAL_GENRES = ["Pop", "Rap", "Latin", "R&b", "Rock", "Edm"];

  const GENRE_STYLES = {
    "Pop":  { h: 330, s: 80, b: 100 }, // pink
    "Rap":  { h: 30,  s: 80, b: 65  }, // brownish
    "Latin":{ h: 50,  s: 90, b: 100 }, // yellow
    "R&b":  { h: 210, s: 80, b: 100 }, // blue
    "Rock": { h: 0,   s: 90, b: 100 }, // red
    "Edm":  { h: 0,   s: 0,  b: 70  }  // gray
  };

  // Layout / legend state
  let genreCenters = {};   // clusterKey -> {nx, ny} in [0,1]
  let genreCounts = {};    // canonical genre -> count (for legend)
  let clusterCounts = {};  // clusterKey -> count (clusterKey is canonical or "Other")

  function setup() {
    canvas = createCanvas(windowWidth, windowHeight);
    canvas.drop(handleFile);
    colorMode(HSB, 360, 100, 100, 100);
  }

  function draw() {
    background(0);

    if (circles.length === 0) {
      drawInstructions();
      return;
    }

    const t = millis() / 1000.0;
    const minDim = min(width, height);
    const marginPx = minDim * MARGIN_NORM;
    const usableW = max(width - marginPx * 2, 10);
    const usableH = max(height - marginPx * 2, 10);

    hoveredIndex = -1;
    let closestDistSq = Infinity;

    // 1) Compute screen positions, animated diameter, and hover
    for (let i = 0; i < circles.length; i++) {
      const c = circles[i];

      const baseD = c.baseDNorm * minDim; // responsive base size
      const speed = 0.5 + c.tempoNorm * 2.0; // faster pulse for higher tempo
      const pulse = sin(TWO_PI * speed * t + c.phase);
      const amp = 0.18; // 18% size variation
      const d = baseD * (1 + amp * pulse);

      c.baseD = baseD;
      c.currentD = d;

      const x = marginPx + c.nx * usableW;
      const y = marginPx + c.ny * usableH;
      c.x = x;
      c.y = y;

      const dx = mouseX - x;
      const dy = mouseY - y;
      const distSq = dx * dx + dy * dy;
      const r = d / 2;

      if (distSq < r * r && distSq < closestDistSq) {
        closestDistSq = distSq;
        hoveredIndex = i;
      }
    }

    // Mouse cursor feedback
    if (hoveredIndex >= 0) {
      cursor('pointer');
    } else {
      cursor('default');
    }

    // 2) Draw circles (hovered one on top with outline)
    noStroke();
    for (let i = 0; i < circles.length; i++) {
      const c = circles[i];
      const d = c.currentD;

      if (i === hoveredIndex) {
        stroke(0, 0, 100, 90);
        strokeWeight(1);
        fill(c.h, c.s, c.b, 90);
        circle(c.x, c.y, d * 1.1);
        noStroke();
      } else {
        fill(c.h, c.s, c.b, 70);
        circle(c.x, c.y, d);
      }
    }

    drawOverlay();
    drawLegend();
    drawTooltip();
  }

  function drawInstructions() {
    fill(0, 0, 90);
    textAlign(CENTER, CENTER);
    textSize(24);
    text("Drop a CSV file onto the screen", width / 2, height / 2 - 20);
    textSize(14);
    text("Color = playlist_genre · Size = danceability · Pulse = tempo", width / 2, height / 2 + 10);
  }

  function drawOverlay() {
    fill(0, 0, 100, 80);
    textAlign(LEFT, TOP);
    textSize(12);

    const genreCount = CANONICAL_GENRES.filter(g => genreCounts[g] > 0).length;

    text(
      `Rows: ${rowsData.length}  |  Circles: ${circles.length}  |  Genres: ${genreCount}`,
      10,
      10
    );
    text("Hover: details · Click: open spotify_url", 10, 26);
  }

  function drawLegend() {
    // Show ONLY the 6 canonical genres that actually appear
    const present = CANONICAL_GENRES.filter(g => genreCounts[g] > 0);
    if (!present.length) return;

    const x = width - 190;
    let y = 20;
    const lineHeight = 16;
    const swatchSize = 10;
    const boxHeight = lineHeight * present.length + 18;

    push();
    noStroke();
    fill(0, 0, 0, 160);
    rect(x - 12, y - 12, 180, boxHeight, 6);

    textAlign(LEFT, CENTER);
    textSize(11);

    for (let i = 0; i < present.length; i++) {
      const g = present[i];
      const style = GENRE_STYLES[g];
      const yy = y + i * lineHeight;

      fill(style.h, style.s, style.b, 90);
      rect(x, yy - swatchSize / 2, swatchSize, swatchSize, 2);

      fill(0, 0, 95, 100);
      text(g, x + swatchSize + 6, yy);
    }
    pop();
  }

  function drawTooltip() {
    if (hoveredIndex < 0) return;
    const c = circles[hoveredIndex];
    const row = rowsData[c.rowIndex];
    if (!row) return;

    const lines = [];
    if (row.track)   lines.push(row.track);
    if (row.artist)  lines.push("by " + row.artist);
    lines.push(row.displayGenre || "Unknown genre");
    if (row.tempo != null) {
      lines.push(`Tempo: ${Math.round(row.tempo)} BPM`);
    }
    if (typeof row.dance === "number") {
      lines.push(`Danceability: ${row.dance.toFixed(2)}`);
    }

    textSize(12);
    textAlign(LEFT, TOP);

    const padding = 8;
    const lineHeight = 14;
    let w = 0;
    for (let l of lines) {
      w = max(w, textWidth(l));
    }

    let x = mouseX + 16;
    let y = mouseY + 16;
    const h = lineHeight * lines.length + padding * 2;

    // keep tooltip on-screen
    if (x + w + padding * 2 > width) {
      x = width - w - padding * 2 - 10;
    }
    if (y + h > height) {
      y = height - h - 10;
    }

    push();
    noStroke();
    fill(0, 0, 0, 210);
    rect(x, y, w + padding * 2, h, 6);

    fill(0, 0, 100, 100);
    let ty = y + padding;
    for (let l of lines) {
      text(l, x + padding, ty);
      ty += lineHeight;
    }
    pop();
  }

  function windowResized() {
    // Only resize the canvas; positions are normalized (0–1)
    // so the layout keeps its shape and scaling feels smooth.
    resizeCanvas(windowWidth, windowHeight);
  }

  function handleFile(file) {
    if (file.type === "text") {
      parseCSV(file.data);
    } else {
      console.log("Not a text file");
    }
  }

  function parseCSV(csvText) {
    const lines = csvText
      .trim()
      .split(/\r?\n/)
      .filter(l => l.trim().length > 0);

    if (lines.length < 2) {
      console.warn("CSV seems to have no data rows.");
      return;
    }

    const firstLine = lines[0];
    const delimiter =
      firstLine.split(";").length > firstLine.split(",").length ? ";" : ",";

    const headers = firstLine.split(delimiter).map(h => h.trim());

    const genreIndex  = headers.indexOf("playlist_genre");
    const danceIndex  = headers.indexOf("danceability");
    const artistIndex = headers.indexOf("artist_name");
    const trackIndex  = headers.indexOf("track_name");
    const urlIndex    = headers.indexOf("spotify_url");
    const tempoIndex  = headers.indexOf("tempo");

    if (genreIndex === -1 || danceIndex === -1) {
      console.warn("CSV must contain playlist_genre and danceability columns.");
      return;
    }

    rowsData = [];
    circles = [];
    genreCenters = {};
    genreCounts = {};
    clusterCounts = {};
    tempoMin = Infinity;
    tempoMax = -Infinity;
    hoveredIndex = -1;

    for (let i = 1; i < lines.length; i++) {
      const parts = lines[i].split(delimiter);
      if (parts.length < headers.length) continue;

      const rawGenre = (parts[genreIndex] || "").trim();
      const canonical = canonicalGenre(rawGenre);  // Pop / Rap / Latin / R&b / Rock / Edm / "Other"
      const clusterKey = CANONICAL_GENRES.includes(canonical) ? canonical : "Other";

      let dance = parseFloat((parts[danceIndex] || "").trim());
      if (isNaN(dance)) dance = 0.5;
      dance = constrain(dance, 0, 1);

      const artist =
        artistIndex !== -1 && parts[artistIndex]
          ? parts[artistIndex].trim()
          : "";
      const track =
        trackIndex !== -1 && parts[trackIndex]
          ? parts[trackIndex].trim()
          : "";
      const url =
        urlIndex !== -1 && parts[urlIndex]
          ? parts[urlIndex].trim()
          : "";

      let tempo = null;
      if (tempoIndex !== -1 && parts[tempoIndex]) {
        const tVal = parseFloat(parts[tempoIndex].trim());
        if (!isNaN(tVal)) tempo = tVal;
      }

      if (tempo != null) {
        tempoMin = min(tempoMin, tempo);
        tempoMax = max(tempoMax, tempo);
      }

      if (CANONICAL_GENRES.includes(canonical)) {
        genreCounts[canonical] = (genreCounts[canonical] || 0) + 1;
      }
      clusterCounts[clusterKey] = (clusterCounts[clusterKey] || 0) + 1;

      rowsData.push({
        cluster: clusterKey,          // cluster key for layout
        genre: canonical,            // canonical genre or "Other"
        displayGenre: canonical === "Other" ? (rawGenre || "Other") : canonical,
        dance,
        artist,
        track,
        url,
        tempo
      });
    }

    if (!rowsData.length) {
      console.warn("No valid data rows found.");
      return;
    }

    if (!isFinite(tempoMin) || !isFinite(tempoMax) || tempoMin === tempoMax) {
      tempoMin = 0;
      tempoMax = 1;
    }

    computeGenreCenters();
    generateCirclesFromData();
  }

  // Map raw genre string to one of the 6 canonical genres or "Other"
  function canonicalGenre(raw) {
    if (!raw) return "Other";
    const g = raw.trim().toLowerCase();

    if (g === "pop") return "Pop";
    if (g === "rap" || g === "hip-hop" || g === "hip hop" || g === "trap")
      return "Rap";
    if (g === "latin") return "Latin";
    if (g === "r&b" || g === "rnb" || g === "r&b;" || g === "r&b/hip hop")
      return "R&b";
    if (g === "rock" || g === "alt rock" || g === "alternative rock")
      return "Rock";
    if (g === "edm" || g === "dance" || g.includes("electronic"))
      return "Edm";

    return "Other";
  }

  function ensureGenreStyle(clusterKey) {
    if (clusterKey === "Other") {
      // Neutral gray for any non-canonical or messy genres
      return { h: 0, s: 0, b: 50 };
    }
    if (GENRE_STYLES[clusterKey]) {
      return GENRE_STYLES[clusterKey];
    }
    // Fallback (shouldn't really happen)
    return { h: 180, s: 0, b: 80 };
  }

  // Compute cluster centers in normalized [0,1] space
  function computeGenreCenters() {
    genreCenters = {};
    const clusterKeys = Object.keys(clusterCounts);
    if (!clusterKeys.length) return;

    const cx = 0.5;
    const cy = 0.5;

    if (clusterKeys.length === 1) {
      genreCenters[clusterKeys[0]] = { nx: cx, ny: cy };
      return;
    }

    const radius = 0.24;
    const step = TWO_PI / clusterKeys.length;

    for (let i = 0; i < clusterKeys.length; i++) {
      const key = clusterKeys[i];
      const angle = i * step;
      const nx = cx + radius * cos(angle);
      const ny = cy + radius * sin(angle);
      genreCenters[key] = {
        nx: constrain(nx, 0.1, 0.9),
        ny: constrain(ny, 0.1, 0.9)
      };
    }
  }

  // Pack circles into one big cloud, clustered by genre, in normalized space
  function generateCirclesFromData() {
    circles = [];
    const clusterKeys = Object.keys(clusterCounts);
    if (!clusterKeys.length) return;

    const maxCount = clusterKeys.reduce(
      (m, k) => Math.max(m, clusterCounts[k]),
      0
    );

    // Spread factor per cluster (bigger for more populated clusters like Pop)
    const clusterSpread = {};
    for (let key of clusterKeys) {
      let factor = 1;
      if (maxCount > 1) {
        const norm = (clusterCounts[key] - 1) / (maxCount - 1); // 0..1
        factor = lerp(0.7, 1.4, norm);
      }
      clusterSpread[key] = SPREAD_NORM_BASE * factor;
    }

    for (let i = 0; i < rowsData.length; i++) {
      const row = rowsData[i];
      const center = genreCenters[row.cluster] || { nx: 0.5, ny: 0.5 };
      const style = ensureGenreStyle(row.cluster);

      const baseDNorm = lerp(MIN_SIZE_FRAC, MAX_SIZE_FRAC, row.dance);
      let tempoNorm = 0.5;
      if (row.tempo != null && tempoMax > tempoMin) {
        tempoNorm = (row.tempo - tempoMin) / (tempoMax - tempoMin);
        tempoNorm = constrain(tempoNorm, 0, 1);
      }

      const spread = clusterSpread[row.cluster] || SPREAD_NORM_BASE;

      let nx = center.nx;
      let ny = center.ny;
      let found = false;

      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        const ang = random(TWO_PI);
        const r = random(spread);
        const candX = center.nx + r * cos(ang);
        const candY = center.ny + r * sin(ang);

        if (
          candX < MARGIN_NORM ||
          candX > 1 - MARGIN_NORM ||
          candY < MARGIN_NORM ||
          candY > 1 - MARGIN_NORM
        ) {
          continue;
        }

        let ok = true;
        for (let c of circles) {
          const minDist = (baseDNorm + c.baseDNorm) * 0.5 + CUSHION_NORM;
          const dx = candX - c.nx;
          const dy = candY - c.ny;
          if (dx * dx + dy * dy < minDist * minDist) {
            ok = false;
            break;
          }
        }

        if (ok) {
          nx = candX;
          ny = candY;
          found = true;
          break;
        }
      }

      if (!found) {
        // Fallback: just clamp to center with small jitter
        const ang = random(TWO_PI);
        const r = random(SPREAD_NORM_BASE * 0.3);
        nx = constrain(center.nx + r * cos(ang), MARGIN_NORM, 1 - MARGIN_NORM);
        ny = constrain(center.ny + r * sin(ang), MARGIN_NORM, 1 - MARGIN_NORM);
      }

      circles.push({
        nx,
        ny,
        baseDNorm,
        tempoNorm,
        phase: random(TWO_PI),
        rowIndex: i,
        h: style.h,
        s: style.s,
        b: style.b,
        baseD: 0,
        currentD: 0
      });
    }
  }

  // Click → open spotify_url
  function mousePressed() {
    if (hoveredIndex < 0) return;
    const c = circles[hoveredIndex];
    const row = rowsData[c.rowIndex];
    if (row && row.url) {
      window.open(row.url, "_blank");
    }
  }
</script>
</body>
</html>
