<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Playlist Cloud – Even Genre Clusters</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
                   "Segoe UI", Roboto, sans-serif;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script>
  let canvas;
  let rowsData = [];
  let circles = [];
  let hoveredIndex = -1;

  // Circle size normalized to min(width, height)
  const MIN_SIZE_NORM = 0.004;  // ~4px at 1000px
  const MAX_SIZE_NORM = 0.02;   // ~20px at 1000px

  // Keep everything away from edges in normalized space
  const MARGIN_NORM = 0.06;

  // Tempo range
  let tempoMin = Infinity;
  let tempoMax = -Infinity;

  // Fixed genre colors
  const GENRE_STYLES = {
    "Pop":  { h: 330, s: 80, b: 100 }, // pink
    "Rap":  { h: 30,  s: 80, b: 65  }, // brown
    "Latin":{ h: 50,  s: 90, b: 100 }, // yellow
    "R&b":  { h: 210, s: 80, b: 100 }, // blue
    "Rock": { h: 0,   s: 90, b: 100 }, // red
    "Edm":  { h: 0,   s: 0,  b: 70  }  // gray
  };

  const LEGEND_ORDER = ["Pop", "Rap", "Latin", "R&b", "Rock", "Edm"];

  // Count per genre (for legend + cluster sizing)
  let genreCount = {
    "Pop": 0,
    "Rap": 0,
    "Latin": 0,
    "R&b": 0,
    "Rock": 0,
    "Edm": 0
  };

  // Layout: genre -> center + spread (all normalized [0,1])
  let genreCenters = {};   // { genre: {nx, ny} }
  let clusterSpread = {};  // { genre: spreadRadius }

  function setup() {
    canvas = createCanvas(windowWidth, windowHeight);
    canvas.drop(handleFile);
    colorMode(HSB, 360, 100, 100, 100);
  }

  function draw() {
    background(0);

    if (!circles.length) {
      drawInstructions();
      return;
    }

    const t = millis() / 1000.0;
    const sizeScale = min(width, height) || 1;

    hoveredIndex = -1;
    let closestDistSq = Infinity;

    // 1) Compute pixel positions, animated diameter, and hover
    for (let i = 0; i < circles.length; i++) {
      const c = circles[i];

      c.x = c.nx * width;
      c.y = c.ny * height;

      const baseD = c.dNorm * sizeScale;
      const speed = 0.5 + c.tempoNorm * 2.0;
      const pulse = sin(TWO_PI * speed * t + c.phase);
      const amp = 0.18;
      const d = baseD * (1 + amp * pulse);

      c.baseD = baseD;
      c.currentD = d;

      const dx = mouseX - c.x;
      const dy = mouseY - c.y;
      const distSq = dx * dx + dy * dy;
      const radius = d / 2;

      if (distSq < radius * radius && distSq < closestDistSq) {
        closestDistSq = distSq;
        hoveredIndex = i;
      }
    }

    // 2) Draw circles (hovered one on top)
    for (let i = 0; i < circles.length; i++) {
      const c = circles[i];
      const d = c.currentD;

      if (i === hoveredIndex) {
        stroke(0, 0, 100, 90);
        strokeWeight(1);
        fill(c.h, c.s, c.b, 85);
        circle(c.x, c.y, d * 1.1);
        noStroke();
      } else {
        noStroke();
        fill(c.h, c.s, c.b, 70);
        circle(c.x, c.y, d);
      }
    }

    cursor(hoveredIndex >= 0 ? 'pointer' : 'default');

    drawOverlay();
    drawLegend();
    drawTooltip();
  }

  function drawInstructions() {
    fill(0, 0, 90);
    textAlign(CENTER, CENTER);
    textSize(24);
    text("Drop a CSV file onto the screen", width / 2, height / 2 - 20);
    textSize(14);
    text("Color = playlist_genre · Size = danceability · Pulse = tempo",
         width / 2, height / 2 + 10);
  }

  function drawOverlay() {
    fill(0, 0, 100, 80);
    textAlign(LEFT, TOP);
    textSize(12);

    const usedGenres = LEGEND_ORDER.filter(g => genreCount[g] > 0);
    text(
      `Rows: ${rowsData.length}  |  Circles: ${circles.length}  |  Genres: ${usedGenres.length}`,
      10,
      10
    );
    text("Hover: details · Click: open spotify_url", 10, 26);
  }

  function drawLegend() {
    const usedGenres = LEGEND_ORDER.filter(g => genreCount[g] > 0);
    if (!usedGenres.length) return;

    const x = width - 190;
    let y = 20;
    const swatchSize = 10;
    const lineHeight = 16;
    const panelHeight = lineHeight * usedGenres.length + 18;

    push();
    noStroke();
    fill(0, 0, 0, 160);
    rect(x - 12, y - 12, 180, panelHeight, 6);
    pop();

    textAlign(LEFT, CENTER);
    textSize(11);

    for (let i = 0; i < usedGenres.length; i++) {
      const g = usedGenres[i];
      const style = GENRE_STYLES[g];
      const yy = y + i * lineHeight;

      fill(style.h, style.s, style.b, 90);
      rect(x, yy - swatchSize / 2, swatchSize, swatchSize, 2);

      fill(0, 0, 95, 100);
      text(g, x + swatchSize + 6, yy);
    }
  }

  function drawTooltip() {
    if (hoveredIndex < 0) return;
    const c = circles[hoveredIndex];
    const row = rowsData[c.rowIndex];
    if (!row) return;

    const lines = [];
    if (row.track)  lines.push(row.track);
    if (row.artist) lines.push("by " + row.artist);
    lines.push(row.genre || "Unknown genre");
    if (row.tempo != null && !isNaN(row.tempo)) {
      lines.push("Tempo: " + Math.round(row.tempo) + " BPM");
    }
    if (typeof row.dance === "number") {
      lines.push("Danceability: " + row.dance.toFixed(2));
    }

    textSize(12);
    textAlign(LEFT, TOP);

    const padding = 8;
    const lineHeight = 14;
    let w = 0;
    for (let l of lines) {
      w = max(w, textWidth(l));
    }

    let x = mouseX + 16;
    let y = mouseY + 16;
    const h = lineHeight * lines.length + padding * 2;

    if (x + w + padding * 2 > width) {
      x = width - w - padding * 2 - 10;
    }
    if (y + h > height) {
      y = height - h - 10;
    }

    push();
    noStroke();
    fill(0, 0, 0, 210);
    rect(x, y, w + padding * 2, h, 6);

    fill(0, 0, 100, 100);
    let ty = y + padding;
    for (let l of lines) {
      text(l, x + padding, ty);
      ty += lineHeight;
    }
    pop();
  }

  function windowResized() {
    // Layout stays in normalized coords; only scaling changes.
    resizeCanvas(windowWidth, windowHeight);
  }

  function handleFile(file) {
    if (file.type === "text") {
      parseCSV(file.data);
    } else {
      console.log("Not a text file");
    }
  }

  function parseCSV(csvText) {
    const lines = csvText
      .trim()
      .split(/\r?\n/)
      .filter(l => l.trim().length > 0);

    if (lines.length < 2) {
      console.warn("CSV has no data rows.");
      return;
    }

    const firstLine = lines[0];
    const delimiter =
      firstLine.split(";").length > firstLine.split(",").length ? ";" : ",";

    const headers = firstLine.split(delimiter).map(h => h.trim());

    const genreIndex  = headers.indexOf("playlist_genre");
    const danceIndex  = headers.indexOf("danceability");
    const artistIndex = headers.indexOf("artist_name");
    const trackIndex  = headers.indexOf("track_name");
    const urlIndex    = headers.indexOf("spotify_url");
    const tempoIndex  = headers.indexOf("tempo");

    if (genreIndex === -1 || danceIndex === -1) {
      console.warn("CSV must contain playlist_genre and danceability columns.");
      return;
    }

    rowsData = [];
    circles = [];
    tempoMin = Infinity;
    tempoMax = -Infinity;

    // reset genre counts
    genreCount = { "Pop":0, "Rap":0, "Latin":0, "R&b":0, "Rock":0, "Edm":0 };

    for (let i = 1; i < lines.length; i++) {
      const parts = lines[i].split(delimiter);
      if (parts.length < headers.length) continue;

      const rawGenre = (parts[genreIndex] || "").trim();
      const canonical = canonicalGenre(rawGenre);
      if (!canonical) continue; // ignore non-6 genres

      let dance = parseFloat((parts[danceIndex] || "").trim());
      if (isNaN(dance)) dance = 0.5;
      dance = Math.max(0, Math.min(1, dance));

      const artist =
        (artistIndex !== -1 && parts[artistIndex]) ? parts[artistIndex].trim() : "";
      const track =
        (trackIndex  !== -1 && parts[trackIndex])  ? parts[trackIndex].trim()  : "";
      const url =
        (urlIndex    !== -1 && parts[urlIndex])    ? parts[urlIndex].trim()    : "";

      let tempo = null;
      if (tempoIndex !== -1 && parts[tempoIndex]) {
        const tVal = parseFloat(parts[tempoIndex].trim());
        if (!isNaN(tVal)) {
          tempo = tVal;
          tempoMin = Math.min(tempoMin, tempo);
          tempoMax = Math.max(tempoMax, tempo);
        }
      }

      genreCount[canonical] = (genreCount[canonical] || 0) + 1;

      rowsData.push({
        genre: canonical,
        dance,
        artist,
        track,
        url,
        tempo
      });
    }

    if (!rowsData.length) {
      console.warn("No valid rows after filtering.");
      return;
    }

    if (!isFinite(tempoMin) || !isFinite(tempoMax) || tempoMin === tempoMax) {
      tempoMin = 0;
      tempoMax = 1;
    }

    computeGenreCenters();
    generateCirclesFromData();
  }

  // Map raw CSV string to one of the 6 canonical genres (or null)
  function canonicalGenre(raw) {
    if (!raw) return null;
    const g = raw.trim().toLowerCase();

    if (g === "pop")   return "Pop";
    if (g === "rap")   return "Rap";
    if (g === "latin") return "Latin";
    if (g === "r&b" || g === "rnb" || g === "r&b;") return "R&b";
    if (g === "rock")  return "Rock";
    if (g === "edm")   return "Edm";

    return null;
  }

  function computeGenreCenters() {
    genreCenters = {};
    clusterSpread = {};

    const usedGenres = LEGEND_ORDER.filter(g => genreCount[g] > 0);
    const n = usedGenres.length;
    if (!n) return;

    const cx = 0.5;
    const cy = 0.5;

    // Where to place the cluster centers around the middle
    const centerRadius = n === 1 ? 0.0 : 0.27;
    const baseSpreadMin = 0.11;
    const baseSpreadMax = 0.16;

    // For scaling cluster areas by popularity (Pop > Edm)
    let maxCount = 0;
    for (let g of usedGenres) {
      if (genreCount[g] > maxCount) maxCount = genreCount[g];
    }
    if (maxCount < 1) maxCount = 1;

    const step = TWO_PI / n;

    for (let i = 0; i < n; i++) {
      const g = usedGenres[i];
      const angle = i * step;

      let nx = cx + centerRadius * cos(angle);
      let ny = cy + centerRadius * sin(angle);

      // keep room for cluster radius + margins
      nx = constrain(nx, MARGIN_NORM + baseSpreadMax, 1 - MARGIN_NORM - baseSpreadMax);
      ny = constrain(ny, MARGIN_NORM + baseSpreadMax, 1 - MARGIN_NORM - baseSpreadMax);

      genreCenters[g] = { nx, ny };

      const f = genreCount[g] / maxCount; // 0..1
      clusterSpread[g] = baseSpreadMin + f * (baseSpreadMax - baseSpreadMin);
    }
  }

  function generateCirclesFromData() {
    circles = [];

    const usedGenres = LEGEND_ORDER.filter(g => genreCount[g] > 0);
    if (!usedGenres.length) return;

    for (let i = 0; i < rowsData.length; i++) {
      const row = rowsData[i];
      const center = genreCenters[row.genre] || { nx: 0.5, ny: 0.5 };
      const spread = clusterSpread[row.genre] || 0.13;
      const style = GENRE_STYLES[row.genre];

      const dNorm =
        MIN_SIZE_NORM + row.dance * (MAX_SIZE_NORM - MIN_SIZE_NORM);

      let tempoNorm = 0.5;
      if (row.tempo != null && isFinite(row.tempo) && tempoMax > tempoMin) {
        tempoNorm = (row.tempo - tempoMin) / (tempoMax - tempoMin);
        tempoNorm = Math.max(0, Math.min(1, tempoNorm));
      }

      // Initial position: uniformly over the cluster disc
      const angle = random(TWO_PI);
      const rNorm = spread * sqrt(random());
      let nx = center.nx + rNorm * cos(angle);
      let ny = center.ny + rNorm * sin(angle);

      nx = constrain(nx, MARGIN_NORM, 1 - MARGIN_NORM);
      ny = constrain(ny, MARGIN_NORM, 1 - MARGIN_NORM);

      circles.push({
        nx,
        ny,
        cx: center.nx,
        cy: center.ny,
        spread,
        dNorm,
        tempoNorm,
        phase: random(TWO_PI),
        h: style.h,
        s: style.s,
        b: style.b,
        rowIndex: i
      });
    }

    relaxCircles(8); // smooth distribution + overlap reduction
  }

  // Simple relaxation: repulsion + gentle attraction to cluster center
  function relaxCircles(iterations) {
    const n = circles.length;
    if (n <= 1) return;

    const cushionNorm = 0.0015;
    const centerPull = 0.03;

    for (let it = 0; it < iterations; it++) {

      // Pairwise repulsion
      for (let i = 0; i < n; i++) {
        const a = circles[i];
        for (let j = i + 1; j < n; j++) {
          const b = circles[j];

          let dx = b.nx - a.nx;
          let dy = b.ny - a.ny;
          const distSq = dx * dx + dy * dy;
          const minDist = (a.dNorm + b.dNorm) * 0.5 + cushionNorm;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq && distSq > 0) {
            const dist = sqrt(distSq);
            const overlap = (minDist - dist) * 0.5;
            const ux = dx / dist;
            const uy = dy / dist;
            a.nx -= ux * overlap;
            a.ny -= uy * overlap;
            b.nx += ux * overlap;
            b.ny += uy * overlap;
          }
        }
      }

      // Attraction back to cluster & clamping
      for (let k = 0; k < n; k++) {
        const c = circles[k];

        // spring towards cluster center
        const dxC = c.cx - c.nx;
        const dyC = c.cy - c.ny;
        c.nx += dxC * centerPull;
        c.ny += dyC * centerPull;

        // keep within cluster disc
        const dxC2 = c.nx - c.cx;
        const dyC2 = c.ny - c.cy;
        const distC = sqrt(dxC2 * dxC2 + dyC2 * dyC2);
        const maxR = c.spread;
        if (distC > maxR && distC > 0) {
          const scale = maxR / distC;
          c.nx = c.cx + dxC2 * scale;
          c.ny = c.cy + dyC2 * scale;
        }

        // global margins
        c.nx = constrain(c.nx, MARGIN_NORM, 1 - MARGIN_NORM);
        c.ny = constrain(c.ny, MARGIN_NORM, 1 - MARGIN_NORM);
      }
    }
  }

  function mousePressed() {
    if (hoveredIndex < 0) return;
    const c = circles[hoveredIndex];
    const row = rowsData[c.rowIndex];
    if (row && row.url) {
      window.open(row.url, "_blank");
    }
  }
</script>
</body>
</html>
